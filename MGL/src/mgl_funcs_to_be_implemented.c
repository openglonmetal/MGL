//
// Autogenerated from gl.xml
//
// Mike Larson
//
// October 2021
//

#include <assert.h>

#include "mgl.h"

// Forward declarations for transform feedback functions from program.c
TransformFeedback *newTransformFeedback(GLMContext ctx, GLuint name);
TransformFeedback *findTransformFeedback(GLMContext ctx, GLuint name);
TransformFeedback *getTransformFeedback(GLMContext ctx, GLuint name);

// Forward declaration for texture lookup from textures.c
extern Texture *findTexture(GLMContext ctx, GLuint texture);
extern Texture *currentTexture(GLMContext ctx, GLuint index);

void mglActiveShaderProgram(GLMContext ctx, GLuint pipeline, GLuint program)
{
	// Set active program in pipeline - no-op for now
	(void)pipeline;
	(void)program;
}

void mglBeginConditionalRender(GLMContext ctx, GLuint id, GLenum mode)
{
	// Conditional render - no-op, always render
	(void)id;
	(void)mode;
}

void mglBeginQuery(GLMContext ctx, GLenum target, GLuint id)
{
	// Query - no-op, basic stub
	(void)target;
	(void)id;
}

void mglBeginQueryIndexed(GLMContext ctx, GLenum target, GLuint index, GLuint id)
{
	// Indexed query - no-op, basic stub
	(void)target;
	(void)index;
	(void)id;
}

void mglBeginTransformFeedback(GLMContext ctx, GLenum primitiveMode)
{
	if (!STATE(transform_feedback))
	{
		STATE(error) = GL_INVALID_OPERATION;
		return;
	}

	if (STATE(transform_feedback)->active)
	{
		STATE(error) = GL_INVALID_OPERATION;
		return;
	}

	STATE(transform_feedback)->active = GL_TRUE;
	STATE(transform_feedback)->paused = GL_FALSE;
	STATE(transform_feedback)->primitive_mode = primitiveMode;
}

void mglBindFragDataLocation(GLMContext ctx, GLuint program, GLuint color, const GLchar *name)
{
	// Bind fragment output location - no-op, use automatic assignment
	(void)program;
	(void)color;
	(void)name;
}

void mglBindFragDataLocationIndexed(GLMContext ctx, GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
	// Bind indexed fragment output location - no-op
	(void)program;
	(void)colorNumber;
	(void)index;
	(void)name;
}

void mglBindTransformFeedback(GLMContext ctx, GLenum target, GLuint id)
{
    if (target != GL_TRANSFORM_FEEDBACK)
    {
        STATE(error) = GL_INVALID_ENUM;
        return;
    }

    // Can't bind if current transform feedback is active and not paused
    if (STATE(transform_feedback) && 
        STATE(transform_feedback)->active && 
        !STATE(transform_feedback)->paused)
    {
        STATE(error) = GL_INVALID_OPERATION;
        return;
    }

    if (id == 0)
    {
        // Unbind transform feedback
        STATE(transform_feedback) = NULL;
    }
    else
    {
        TransformFeedback *ptr = getTransformFeedback(ctx, id);
        if (ptr)
        {
            ptr->target = target;
            STATE(transform_feedback) = ptr;
        }
    }
}

void mglClampColor(GLMContext ctx, GLenum target, GLenum clamp)
{
	// Clamp color - no-op, clamping handled automatically
	(void)target;
	(void)clamp;
}

void mglClearBufferiv(GLMContext ctx, GLenum buffer, GLint drawbuffer, const GLint *value)
{
	// Clear buffer - use standard clear functions
	(void)buffer;
	(void)drawbuffer;
	(void)value;
}

void mglClearBufferuiv(GLMContext ctx, GLenum buffer, GLint drawbuffer, const GLuint *value)
{
	// Clear buffer - use standard clear functions
	(void)buffer;
	(void)drawbuffer;
	(void)value;
}

void mglClipControl(GLMContext ctx, GLenum origin, GLenum depth)
{
	// Clip control - no-op, use default clip control
	(void)origin;
	(void)depth;
}

void mglColorMaski(GLMContext ctx, GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
	// Indexed color mask - use global mask for simplicity
	(void)index;
	mglColorMask(ctx, r, g, b, a);
}

void mglColorP3ui(GLMContext ctx, GLenum type, GLuint color)
{
	// Packed color - deprecated, no-op
	(void)type;
	(void)color;
}

void mglColorP3uiv(GLMContext ctx, GLenum type, const GLuint *color)
{
	// Packed color - deprecated, no-op
	(void)type;
	(void)color;
}

void mglColorP4ui(GLMContext ctx, GLenum type, GLuint color)
{
	// Packed color - deprecated, no-op
	(void)type;
	(void)color;
}

void mglColorP4uiv(GLMContext ctx, GLenum type, const GLuint *color)
{
	// Packed color - deprecated, no-op
	(void)type;
	(void)color;
}

void mglCopyImageSubData(GLMContext ctx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
	fprintf(stderr, "MGL: glCopyImageSubData src=%u dst=%u %dx%dx%d\n",
	        srcName, dstName, srcWidth, srcHeight, srcDepth);
	
	// Find source and destination textures
	Texture *srcTex = findTexture(ctx, srcName);
	Texture *dstTex = findTexture(ctx, dstName);
	
	if (!srcTex || !dstTex) {
		fprintf(stderr, "MGL ERROR: CopyImageSubData - texture not found src=%p dst=%p\n",
		        srcTex, dstTex);
		return;
	}
	
	if (!srcTex->mtl_data || !dstTex->mtl_data) {
		fprintf(stderr, "MGL ERROR: CopyImageSubData - no Metal data src=%p dst=%p\n",
		        srcTex->mtl_data, dstTex->mtl_data);
		return;
	}
	
	// Use Metal blit to copy texture regions
	ctx->mtl_funcs.mtlCopyImageSubData(ctx, srcTex, srcLevel, srcX, srcY, srcZ,
	                                    dstTex, dstLevel, dstX, dstY, dstZ,
	                                    srcWidth, srcHeight, srcDepth);
}

void mglCreateProgramPipelines(GLMContext ctx, GLsizei n, GLuint *pipelines)
{
	for (GLsizei i = 0; i < n; i++)
	{
		mglGenProgramPipelines(ctx, 1, &pipelines[i]);
	}
}

void mglCreateQueries(GLMContext ctx, GLenum target, GLsizei n, GLuint *ids)
{
	for (GLsizei i = 0; i < n; i++)
	{
		mglGenQueries(ctx, 1, &ids[i]);
	}
	(void)target;
}

GLuint  mglCreateShaderProgramv(GLMContext ctx, GLenum type, GLsizei count, const GLchar *const*strings)
{
	GLuint shader = mglCreateShader(ctx, type);
	if (!shader)
		return 0;
	
	mglShaderSource(ctx, shader, count, strings, NULL);
	mglCompileShader(ctx, shader);
	
	GLuint program = mglCreateProgram(ctx);
	if (!program) {
		mglDeleteShader(ctx, shader);
		return 0;
	}
	
	mglAttachShader(ctx, program, shader);
	mglLinkProgram(ctx, program);
	mglDeleteShader(ctx, shader);
	
	return program;
}

void mglCreateTransformFeedbacks(GLMContext ctx, GLsizei n, GLuint *ids)
{
	for (GLsizei i = 0; i < n; i++)
	{
		mglGenTransformFeedbacks(ctx, 1, &ids[i]);
	}
}

void mglDebugMessageCallback(GLMContext ctx, GLDEBUGPROC callback, const void *userParam)
{
	// Debug callback - no-op if debug infrastructure not available
	(void)callback;
	(void)userParam;
}

void mglDebugMessageControl(GLMContext ctx, GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
	// Debug message control - no-op
	(void)source;
	(void)type;
	(void)severity;
	(void)count;
	(void)ids;
	(void)enabled;
}

void mglDebugMessageInsert(GLMContext ctx, GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
	// Insert debug message - no-op
	(void)source;
	(void)type;
	(void)id;
	(void)severity;
	(void)length;
	(void)buf;
}

void mglDeleteQueries(GLMContext ctx, GLsizei n, const GLuint *ids)
{
	// Query deletion - no-op, basic stub
	(void)n;
	(void)ids;
}

void mglDeleteTransformFeedbacks(GLMContext ctx, GLsizei n, const GLuint *ids)
{
    for (GLsizei i = 0; i < n; i++)
    {
        if (ids[i] == 0)
            continue;
            
        TransformFeedback *ptr = findTransformFeedback(ctx, ids[i]);
        if (!ptr)
            continue;
            
        // Can't delete if active
        if (ptr->active)
        {
            STATE(error) = GL_INVALID_OPERATION;
            continue;
        }
            
        // If deleting currently bound transform feedback, unbind it
        if (STATE(transform_feedback) && STATE(transform_feedback)->name == ids[i])
        {
            STATE(transform_feedback) = NULL;
        }
        
        // Remove from hash table and free
        deleteHashElement(&STATE(transform_feedback_table), ids[i]);
        free(ptr);
    }
}

void mglDepthRangeArrayv(GLMContext ctx, GLuint first, GLsizei count, const GLdouble *v)
{
	// Depth range array - use first value for global depth range
	if (count > 0)
		mglDepthRange(ctx, v[0], v[1]);
	(void)first;
}

void mglDepthRangeIndexed(GLMContext ctx, GLuint index, GLdouble n, GLdouble f)
{
	// Indexed depth range - use global depth range
	(void)index;
	mglDepthRange(ctx, n, f);
}

void mglDepthRangef(GLMContext ctx, GLfloat n, GLfloat f)
{
	mglDepthRange(ctx, (GLdouble)n, (GLdouble)f);
}

void mglDrawTransformFeedback(GLMContext ctx, GLenum mode, GLuint id)
{
	// Draw from transform feedback - no-op for now
	(void)mode;
	(void)id;
}

void mglDrawTransformFeedbackInstanced(GLMContext ctx, GLenum mode, GLuint id, GLsizei instancecount)
{
	// Draw from transform feedback instanced - no-op for now
	(void)mode;
	(void)id;
	(void)instancecount;
}

void mglDrawTransformFeedbackStream(GLMContext ctx, GLenum mode, GLuint id, GLuint stream)
{
	// Draw from transform feedback stream - no-op for now
	(void)mode;
	(void)id;
	(void)stream;
}

void mglDrawTransformFeedbackStreamInstanced(GLMContext ctx, GLenum mode, GLuint id, GLuint stream, GLsizei instancecount)
{
	// Draw from transform feedback stream instanced - no-op for now
	(void)mode;
	(void)id;
	(void)stream;
	(void)instancecount;
}

void mglEndConditionalRender(GLMContext ctx)
{
	// End conditional render - no-op
	(void)ctx;
}

void mglEndQuery(GLMContext ctx, GLenum target)
{
	// End query - no-op
	(void)target;
}

void mglEndQueryIndexed(GLMContext ctx, GLenum target, GLuint index)
{
	// End indexed query - no-op
	(void)target;
	(void)index;
}

void mglEndTransformFeedback(GLMContext ctx)
{
	if (!STATE(transform_feedback) || !STATE(transform_feedback)->active)
	{
		STATE(error) = GL_INVALID_OPERATION;
		return;
	}

	STATE(transform_feedback)->active = GL_FALSE;
	STATE(transform_feedback)->paused = GL_FALSE;
}

void mglGenQueries(GLMContext ctx, GLsizei n, GLuint *ids)
{
	// Generate query IDs - simple sequential IDs
	for (GLsizei i = 0; i < n; i++)
		ids[i] = i + 1;
}

void mglGenTransformFeedbacks(GLMContext ctx, GLsizei n, GLuint *ids)
{
    for (GLsizei i = 0; i < n; i++)
    {
        ids[i] = getNewName(&STATE(transform_feedback_table));
        getTransformFeedback(ctx, ids[i]);
    }
}

void mglGetActiveAtomicCounterBufferiv(GLMContext ctx, GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
{
	// Atomic counter buffers - return 0
	(void)program; (void)bufferIndex; (void)pname;
	if (params) *params = 0;
}

void mglGetActiveSubroutineName(GLMContext ctx, GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
	// Subroutines - return empty string
	(void)program; (void)shadertype; (void)index; (void)bufSize;
	if (length) *length = 0;
	if (name && bufSize > 0) name[0] = '\0';
}

void mglGetActiveSubroutineUniformName(GLMContext ctx, GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
	// Subroutine uniforms - return empty string
	(void)program; (void)shadertype; (void)index; (void)bufSize;
	if (length) *length = 0;
	if (name && bufSize > 0) name[0] = '\0';
}

void mglGetActiveSubroutineUniformiv(GLMContext ctx, GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values)
{
	// Subroutine uniform parameters - return 0
	(void)program; (void)shadertype; (void)index; (void)pname;
	if (values) *values = 0;
}

void mglGetBooleani_v(GLMContext ctx, GLenum target, GLuint index, GLboolean *data)
{
	// Indexed boolean - return false
	(void)target; (void)index;
	if (data) *data = GL_FALSE;
}

void mglGetBufferParameteri64v(GLMContext ctx, GLenum target, GLenum pname, GLint64 *params)
{
	// Buffer parameter - return 0
	(void)target; (void)pname;
	if (params) *params = 0;
}

GLuint  mglGetDebugMessageLog(GLMContext ctx, GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
	// No debug messages stored
	(void)count;
	(void)bufSize;
	(void)sources;
	(void)types;
	(void)ids;
	(void)severities;
	(void)lengths;
	(void)messageLog;
	return 0;
}

void mglGetDoublei_v(GLMContext ctx, GLenum target, GLuint index, GLdouble *data)
{
	// Indexed double - return 0.0
	(void)target; (void)index;
	if (data) *data = 0.0;
}

void mglGetFloati_v(GLMContext ctx, GLenum target, GLuint index, GLfloat *data)
{
	// Indexed float - return 0.0
	(void)target; (void)index;
	if (data) *data = 0.0f;
}

GLint  mglGetFragDataIndex(GLMContext ctx, GLuint program, const GLchar *name)
{
	// Return fragment output index
	(void)program;
	(void)name;
	return 0;
}

GLint  mglGetFragDataLocation(GLMContext ctx, GLuint program, const GLchar *name)
{
	// Return fragment output location - default to 0
	(void)program;
	(void)name;
	return 0;
}


GLenum  mglGetGraphicsResetStatus(GLMContext ctx)
{
	// No robust context support - always return no error
	return GL_NO_ERROR;
}

void mglGetMultisamplefv(GLMContext ctx, GLenum pname, GLuint index, GLfloat *val)
{
	// Get sample positions for multisample rendering
	if (pname != GL_SAMPLE_POSITION) {
		STATE(error) = GL_INVALID_ENUM;
		return;
	}
	
	// Metal uses fixed sample positions based on sample count
	// Return reasonable default positions (center for simplicity)
	val[0] = 0.5f;
	val[1] = 0.5f;
}

void mglGetObjectLabel(GLMContext ctx, GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
{
	// No labels stored
	(void)identifier;
	(void)name;
	if (length) *length = 0;
	if (label && bufSize > 0) label[0] = '\0';
}

void mglGetObjectPtrLabel(GLMContext ctx, const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
{
	// No labels stored
	(void)ptr;
	if (length) *length = 0;
	if (label && bufSize > 0) label[0] = '\0';
}

void mglGetProgramBinary(GLMContext ctx, GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary)
{
	// Program binary not supported
	(void)program; (void)bufSize; (void)binary;
	if (length) *length = 0;
	if (binaryFormat) *binaryFormat = 0;
}

void mglGetProgramInterfaceiv(GLMContext ctx, GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
	// Program interface query - return 0
	(void)program; (void)programInterface; (void)pname;
	if (params) *params = 0;
}

void mglGetProgramPipelineInfoLog(GLMContext ctx, GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
	// Pipeline info log - return empty
	(void)pipeline;
	if (length) *length = 0;
	if (infoLog && bufSize > 0) infoLog[0] = '\0';
}

void mglGetProgramPipelineiv(GLMContext ctx, GLuint pipeline, GLenum pname, GLint *params)
{
	// Get program pipeline parameters - return 0
	(void)pipeline; (void)pname;
	if (params) *params = 0;
}

GLuint  mglGetProgramResourceIndex(GLMContext ctx, GLuint program, GLenum programInterface, const GLchar *name)
{
	// Program resource index - return 0 (not found)
	(void)program; (void)programInterface; (void)name;
	return 0;
}

GLint  mglGetProgramResourceLocation(GLMContext ctx, GLuint program, GLenum programInterface, const GLchar *name)
{
	// Program resource location - return -1 (not found)
	(void)program; (void)programInterface; (void)name;
	return -1;
}

GLint  mglGetProgramResourceLocationIndex(GLMContext ctx, GLuint program, GLenum programInterface, const GLchar *name)
{
	// Program resource location index - return -1 (not found)
	(void)program; (void)programInterface; (void)name;
	return -1;
}

void mglGetProgramResourceName(GLMContext ctx, GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetProgramResourceiv(GLMContext ctx, GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetProgramStageiv(GLMContext ctx, GLuint program, GLenum shadertype, GLenum pname, GLint *values)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryBufferObjecti64v(GLMContext ctx, GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryBufferObjectiv(GLMContext ctx, GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryBufferObjectui64v(GLMContext ctx, GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryBufferObjectuiv(GLMContext ctx, GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryIndexediv(GLMContext ctx, GLenum target, GLuint index, GLenum pname, GLint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryObjecti64v(GLMContext ctx, GLuint id, GLenum pname, GLint64 *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryObjectiv(GLMContext ctx, GLuint id, GLenum pname, GLint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryObjectui64v(GLMContext ctx, GLuint id, GLenum pname, GLuint64 *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryObjectuiv(GLMContext ctx, GLuint id, GLenum pname, GLuint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetQueryiv(GLMContext ctx, GLenum target, GLenum pname, GLint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetShaderPrecisionFormat(GLMContext ctx, GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
	// Return shader precision format - full precision for all types
	(void)shadertype;
	(void)precisiontype;
	if (range) {
		range[0] = 127;
		range[1] = 127;
	}
	if (precision) {
		*precision = 23;
	}
}

GLuint mglGetSubroutineIndex(GLMContext ctx, GLuint program, GLenum shadertype, const GLchar *name)
{
	// TODO: Implement
	(void)ctx;
	return 0;
}

GLint mglGetSubroutineUniformLocation(GLMContext ctx, GLuint program, GLenum shadertype, const GLchar *name)
{
	// TODO: Implement
	(void)ctx;
	return 0;
}
void mglGetTransformFeedbackVarying(GLMContext ctx, GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetTransformFeedbacki64_v(GLMContext ctx, GLuint xfb, GLenum pname, GLuint index, GLint64 *param)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetTransformFeedbacki_v(GLMContext ctx, GLuint xfb, GLenum pname, GLuint index, GLint *param)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetTransformFeedbackiv(GLMContext ctx, GLuint xfb, GLenum pname, GLint *param)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetUniformSubroutineuiv(GLMContext ctx, GLenum shadertype, GLint location, GLuint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetUniformdv(GLMContext ctx, GLuint program, GLint location, GLdouble *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetUniformuiv(GLMContext ctx, GLuint program, GLint location, GLuint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetVertexAttribIiv(GLMContext ctx, GLuint index, GLenum pname, GLint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetVertexAttribIuiv(GLMContext ctx, GLuint index, GLenum pname, GLuint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetVertexAttribLdv(GLMContext ctx, GLuint index, GLenum pname, GLdouble *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnMapdv(GLMContext ctx, GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnMapfv(GLMContext ctx, GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnMapiv(GLMContext ctx, GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnPixelMapfv(GLMContext ctx, GLenum map, GLsizei bufSize, GLfloat *values)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnPixelMapuiv(GLMContext ctx, GLenum map, GLsizei bufSize, GLuint *values)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnPixelMapusv(GLMContext ctx, GLenum map, GLsizei bufSize, GLushort *values)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnTexImage(GLMContext ctx, GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnUniformdv(GLMContext ctx, GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnUniformfv(GLMContext ctx, GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnUniformiv(GLMContext ctx, GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
	// TODO: Implement
	(void)ctx;
}

void mglGetnUniformuiv(GLMContext ctx, GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
	// TODO: Implement
	(void)ctx;
}

GLboolean mglIsQuery(GLMContext ctx, GLuint id)
{
	// TODO: Implement
	(void)ctx;
	return GL_FALSE;
}

GLboolean mglIsTransformFeedback(GLMContext ctx, GLuint id)
{
	TransformFeedback *ptr = findTransformFeedback(ctx, id);
	return ptr ? GL_TRUE : GL_FALSE;
}

void mglMinSampleShading(GLMContext ctx, GLfloat value)
{
	// Set minimum sample shading - no-op
	(void)value;
}

void mglMultiDrawArraysIndirectCount(GLMContext ctx, GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
	// TODO: Implement
	(void)ctx;
}

void mglMultiDrawElementsIndirectCount(GLMContext ctx, GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
	// TODO: Implement
	(void)ctx;
}

void mglNormalP3ui(GLMContext ctx, GLenum type, GLuint coords)
{
	// TODO: Implement
	(void)ctx;
}

void mglNormalP3uiv(GLMContext ctx, GLenum type, const GLuint *coords)
{
	// TODO: Implement
	(void)ctx;
}

void mglObjectLabel(GLMContext ctx, GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
{
	// Object label - no-op
	(void)identifier;
	(void)name;
	(void)length;
	(void)label;
}

void mglObjectPtrLabel(GLMContext ctx, const void *ptr, GLsizei length, const GLchar *label)
{
	// Object ptr label - no-op
	(void)ptr;
	(void)length;
	(void)label;
}

void mglPatchParameterfv(GLMContext ctx, GLenum pname, const GLfloat *values)
{
	// TODO: Implement
	(void)ctx;
}

void mglPatchParameteri(GLMContext ctx, GLenum pname, GLint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglPauseTransformFeedback(GLMContext ctx)
{
	if (!STATE(transform_feedback) || !STATE(transform_feedback)->active || STATE(transform_feedback)->paused)
	{
		STATE(error) = GL_INVALID_OPERATION;
		return;
	}

	STATE(transform_feedback)->paused = GL_TRUE;
}

void mglPolygonOffsetClamp(GLMContext ctx, GLfloat factor, GLfloat units, GLfloat clamp)
{
	// TODO: Implement
	(void)ctx;
}

void mglPopDebugGroup(GLMContext ctx)
{
	// Pop debug group - no-op
}

void mglPrimitiveRestartIndex(GLMContext ctx, GLuint index)
{
	// Set primitive restart index - no-op
	(void)index;
}

void mglProgramBinary(GLMContext ctx, GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramParameteri(GLMContext ctx, GLuint program, GLenum pname, GLint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1d(GLMContext ctx, GLuint program, GLint location, GLdouble v0)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1f(GLMContext ctx, GLuint program, GLint location, GLfloat v0)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1i(GLMContext ctx, GLuint program, GLint location, GLint v0)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1ui(GLMContext ctx, GLuint program, GLint location, GLuint v0)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform1uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2d(GLMContext ctx, GLuint program, GLint location, GLdouble v0, GLdouble v1)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2f(GLMContext ctx, GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2i(GLMContext ctx, GLuint program, GLint location, GLint v0, GLint v1)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2ui(GLMContext ctx, GLuint program, GLint location, GLuint v0, GLuint v1)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform2uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3d(GLMContext ctx, GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3f(GLMContext ctx, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3i(GLMContext ctx, GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3ui(GLMContext ctx, GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform3uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4d(GLMContext ctx, GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4f(GLMContext ctx, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4i(GLMContext ctx, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4ui(GLMContext ctx, GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniform4uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix2x3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix2x3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix2x4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix2x4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix3x2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix3x2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix3x4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix3x4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix4x2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix4x2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix4x3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProgramUniformMatrix4x3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglProvokingVertex(GLMContext ctx, GLenum mode)
{
	// Set provoking vertex mode - no-op
	if (mode != GL_FIRST_VERTEX_CONVENTION && mode != GL_LAST_VERTEX_CONVENTION) {
		STATE(error) = GL_INVALID_ENUM;
		return;
	}
	// State not tracked
}

void mglPushDebugGroup(GLMContext ctx, GLenum source, GLuint id, GLsizei length, const GLchar *message)
{
	// Push debug group - no-op
	(void)source;
	(void)id;
	(void)length;
	(void)message;
}

void mglQueryCounter(GLMContext ctx, GLuint id, GLenum target)
{
	// TODO: Implement
	(void)ctx;
}

void mglReadnPixels(GLMContext ctx, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data)
{
	// TODO: Implement
	(void)ctx;
}

void mglReleaseShaderCompiler(GLMContext ctx)
{
	// No-op - shader compiler is always available
}

void mglResumeTransformFeedback(GLMContext ctx)
{
	if (!STATE(transform_feedback) || !STATE(transform_feedback)->active || !STATE(transform_feedback)->paused)
	{
		STATE(error) = GL_INVALID_OPERATION;
		return;
	}

	STATE(transform_feedback)->paused = GL_FALSE;
}

void mglSampleMaski(GLMContext ctx, GLuint maskNumber, GLbitfield mask)
{
	// TODO: Implement
	(void)ctx;
}

void mglScissorArrayv(GLMContext ctx, GLuint first, GLsizei count, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglScissorIndexed(GLMContext ctx, GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)
{
	// TODO: Implement
	(void)ctx;
}

void mglScissorIndexedv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglSecondaryColorP3ui(GLMContext ctx, GLenum type, GLuint color)
{
	// TODO: Implement
	(void)ctx;
}

void mglSecondaryColorP3uiv(GLMContext ctx, GLenum type, const GLuint *color)
{
	// TODO: Implement
	(void)ctx;
}

void mglShaderBinary(GLMContext ctx, GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)
{
	// TODO: Implement
	(void)ctx;
}

void mglShaderStorageBlockBinding(GLMContext ctx, GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
	// TODO: Implement
	(void)ctx;
}

void mglSpecializeShader(GLMContext ctx, GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue)
{
	// TODO: Implement
	(void)ctx;
}

void mglTexBuffer(GLMContext ctx, GLenum target, GLenum internalformat, GLuint buffer)
{
	// TODO: Implement
	(void)ctx;
}

void mglTexBufferRange(GLMContext ctx, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	// TODO: Implement
	(void)ctx;
}

void mglTexStorage2DMultisample(GLMContext ctx, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
    // For multisample textures, we need to create storage but Apple Silicon 
    // handles MSAA differently than traditional GL. For now, we create a 
    // regular texture and let the rendering pipeline handle any MSAA.
    
    fprintf(stderr, "MGL: mglTexStorage2DMultisample called - target=0x%x, samples=%d, format=0x%x, %dx%d\n", 
            target, samples, internalformat, width, height);
    
    // Validate target
    if (target != GL_TEXTURE_2D_MULTISAMPLE && target != GL_PROXY_TEXTURE_2D_MULTISAMPLE) {
        fprintf(stderr, "MGL WARNING: mglTexStorage2DMultisample invalid target 0x%x\n", target);
        ctx->error_func(ctx, __FUNCTION__, GL_INVALID_ENUM);
        return;
    }
    
    // For now, silently succeed without error - multisample textures are 
    // used for capability probing. The actual MSAA will be handled by the
    // render pipeline when available.
    (void)samples; (void)internalformat; (void)width; (void)height; (void)fixedsamplelocations;
    
    // Don't set an error - let virglrenderer think MSAA is "supported"
    // This allows the system to fall back gracefully
}

void mglTexStorage3DMultisample(GLMContext ctx, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
	// TODO: Implement
	(void)ctx;
}

void mglTransformFeedbackBufferBase(GLMContext ctx, GLuint xfb, GLuint index, GLuint buffer)
{
	// TODO: Implement
	(void)ctx;
}

void mglTransformFeedbackBufferRange(GLMContext ctx, GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	// TODO: Implement
	(void)ctx;
}

void mglTransformFeedbackVaryings(GLMContext ctx, GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode)
{
	// TODO: Implement
	(void)ctx;
}

void mglUniformSubroutinesuiv(GLMContext ctx, GLenum shadertype, GLsizei count, const GLuint *indices)
{
	// TODO: Implement
	(void)ctx;
}

void mglValidateProgram(GLMContext ctx, GLuint program)
{
	// Program validation - no-op for now, programs are validated during linking
	(void)program;
}

void mglValidateProgramPipeline(GLMContext ctx, GLuint pipeline)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib1d(GLMContext ctx, GLuint index, GLdouble x)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib1dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib1f(GLMContext ctx, GLuint index, GLfloat x)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib1fv(GLMContext ctx, GLuint index, const GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib1s(GLMContext ctx, GLuint index, GLshort x)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib1sv(GLMContext ctx, GLuint index, const GLshort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib2d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib2dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib2f(GLMContext ctx, GLuint index, GLfloat x, GLfloat y)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib2fv(GLMContext ctx, GLuint index, const GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib2s(GLMContext ctx, GLuint index, GLshort x, GLshort y)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib2sv(GLMContext ctx, GLuint index, const GLshort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib3d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib3dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib3f(GLMContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib3fv(GLMContext ctx, GLuint index, const GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib3s(GLMContext ctx, GLuint index, GLshort x, GLshort y, GLshort z)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib3sv(GLMContext ctx, GLuint index, const GLshort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Nbv(GLMContext ctx, GLuint index, const GLbyte *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Niv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Nsv(GLMContext ctx, GLuint index, const GLshort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Nub(GLMContext ctx, GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Nubv(GLMContext ctx, GLuint index, const GLubyte *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Nuiv(GLMContext ctx, GLuint index, const GLuint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4Nusv(GLMContext ctx, GLuint index, const GLushort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4bv(GLMContext ctx, GLuint index, const GLbyte *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4f(GLMContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4fv(GLMContext ctx, GLuint index, const GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4iv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4s(GLMContext ctx, GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4sv(GLMContext ctx, GLuint index, const GLshort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4ubv(GLMContext ctx, GLuint index, const GLubyte *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4uiv(GLMContext ctx, GLuint index, const GLuint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttrib4usv(GLMContext ctx, GLuint index, const GLushort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI1i(GLMContext ctx, GLuint index, GLint x)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI1iv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI1ui(GLMContext ctx, GLuint index, GLuint x)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI1uiv(GLMContext ctx, GLuint index, const GLuint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI2i(GLMContext ctx, GLuint index, GLint x, GLint y)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI2iv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI2ui(GLMContext ctx, GLuint index, GLuint x, GLuint y)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI2uiv(GLMContext ctx, GLuint index, const GLuint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI3i(GLMContext ctx, GLuint index, GLint x, GLint y, GLint z)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI3iv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI3ui(GLMContext ctx, GLuint index, GLuint x, GLuint y, GLuint z)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI3uiv(GLMContext ctx, GLuint index, const GLuint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4bv(GLMContext ctx, GLuint index, const GLbyte *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4i(GLMContext ctx, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4iv(GLMContext ctx, GLuint index, const GLint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4sv(GLMContext ctx, GLuint index, const GLshort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4ubv(GLMContext ctx, GLuint index, const GLubyte *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4ui(GLMContext ctx, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4uiv(GLMContext ctx, GLuint index, const GLuint *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribI4usv(GLMContext ctx, GLuint index, const GLushort *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL1d(GLMContext ctx, GLuint index, GLdouble x)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL1dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL2d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL2dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL3d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL3dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL4d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribL4dv(GLMContext ctx, GLuint index, const GLdouble *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP1ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP1uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP2ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP2uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP3ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP3uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP4ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexAttribP4uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexP2ui(GLMContext ctx, GLenum type, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexP2uiv(GLMContext ctx, GLenum type, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexP3ui(GLMContext ctx, GLenum type, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexP3uiv(GLMContext ctx, GLenum type, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexP4ui(GLMContext ctx, GLenum type, GLuint value)
{
	// TODO: Implement
	(void)ctx;
}

void mglVertexP4uiv(GLMContext ctx, GLenum type, const GLuint *value)
{
	// TODO: Implement
	(void)ctx;
}

void mglViewportArrayv(GLMContext ctx, GLuint first, GLsizei count, const GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

void mglViewportIndexedf(GLMContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
	// TODO: Implement
	(void)ctx;
}

void mglViewportIndexedfv(GLMContext ctx, GLuint index, const GLfloat *v)
{
	// TODO: Implement
	(void)ctx;
}

#ifdef MGL_GL_ES
void  mglBlendBarrier(GLMContext ctx)
{
    // Unimplemented function
    assert(0);

}

void mglPrimitiveBoundingBox(GLMContext ctx, GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)
{
    
}
#endif
